import {
  ConnectionStatus,
  AnyNetworkMessage,
  MessageType,
  PlayerRole,
  SessionInfo,
  GameStateMessage,
} from "../types";
import remoteSignalingService from "./RemoteSignalingService";

/**
 * Configuration for WebRTC peer connection
 */
interface WebRTCConfig {
  iceServers: RTCIceServer[];
  timeout: number;
}

/**
 * Default configuration for WebRTC
 */
const DEFAULT_CONFIG: WebRTCConfig = {
  iceServers: [
    {
      urls: [
        "stun:stun.l.google.com:19302",
        "stun:stun1.l.google.com:19302",
        "stun:stun2.l.google.com:19302",
        "stun:stun3.l.google.com:19302",
        "stun:stun.stunprotocol.org:3478",
        "stun:stun.ekiga.net:3478",
        "stun:stun.ideasip.com:3478",
        "stun:stun.voiparound.com:3478",
      ],
    },
    // Fallback public TURN server (limited capacity)
    {
      urls: "turn:openrelay.metered.ca:80",
      username: "openrelayproject",
      credential: "openrelayproject",
    },
  ],
  timeout: 60000, // 60 seconds connection timeout (increased for Windows)
};

/**
 * WebRTC service for peer-to-peer connection in the Pong game
 */
export class WebRTCService {
  private peerConnection: RTCPeerConnection | null = null;
  private dataChannel: RTCDataChannel | null = null;
  private connectionStatus: ConnectionStatus = ConnectionStatus.DISCONNECTED;
  private config: WebRTCConfig;
  private role: PlayerRole = PlayerRole.HOST;
  private sessionInfo: SessionInfo | null = null;
  private connectionTimeout: number | null = null;
  private pingInterval: number | null = null;
  private lastPingTime: number = 0;
  private lastPongTime: number = 0;
  private messageHandlers: Map<
    MessageType,
    ((message: AnyNetworkMessage) => void)[]
  > = new Map();

  /**
   * Event listeners
   */
  private onStatusChangeListeners: ((status: ConnectionStatus) => void)[] = [];
  private onConnectedListeners: (() => void)[] = [];
  private onDisconnectedListeners: (() => void)[] = [];
  private onErrorListeners: ((error: Error) => void)[] = [];

  constructor(config: Partial<WebRTCConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Initialize a new session as host
   * @returns The session code to share with the client
   */
  public initHostSession(password?: string): string {
    // Clean up any existing connection
    this.close();

    this.role = PlayerRole.HOST;

    // Initialize the connection first
    this.initializeConnection();

    // Start with a temporary code
    const tempCode = Math.random().toString(36).substring(2, 8).toUpperCase();

    this.sessionInfo = {
      code: tempCode,
      isHost: true,
      password,
      role: PlayerRole.HOST,
    };

    // Connect to the remote signaling service and create a session
    remoteSignalingService
      .createSession()
      .then((sessionInfo) => {
        // Update with the real session code from the server
        this.sessionInfo = {
          code: sessionInfo.sessionId,
          isHost: true,
          password,
          role: PlayerRole.HOST,
        };

        // Fire an event that listeners can use to update UI
        window.dispatchEvent(
          new CustomEvent("permanent-code-received", {
            detail: { code: sessionInfo.sessionId },
          })
        );

        // Create and send the offer once we have the session
        this.createAndSendOffer();

        // Set up remote signaling handlers
        this.setupSignalingHandlers();
      })
      .catch((error) => {
        console.error("=== HOST SESSION CREATION FAILED ===");
        console.error(`Error details: ${error.message}`);
        console.error("Stack trace:", error.stack);
        this.handleConnectionError(
          new Error(`Failed to create session: ${error.message}`)
        );
      });

    return tempCode; // Will be updated later with the real code
  }

  /**
   * Check if this looks like a temporary code generated by this app
   * @param code The code to check
   * @returns True if the code matches our temporary code pattern
   */
  private isTemporaryCode(code: string): boolean {
    // Our temporary codes are 6 characters with numbers and uppercase letters
    return (
      /^[A-Z0-9]{6}$/.test(code) &&
      !code.includes("EB") && // Permanent codes from Railway often contain "EB"
      code.length === 6 &&
      /[0-9]/.test(code) && // Has at least one number
      /[A-Z]/.test(code)
    ); // Has at least one uppercase letter
  }

  /**
   * Join an existing session as client
   * @param sessionCode The session code provided by the host
   * @param password Optional password for the session
   */
  public async joinSession(
    sessionCode: string,
    password?: string
  ): Promise<void> {
    // Clean up any existing connection
    try {
      this.close();
      // Add a small delay to ensure cleanup is complete
      await new Promise((resolve) => setTimeout(resolve, 500));
    } catch (error) {
      console.error("Error during connection cleanup:", error);
    }

    // Validate session code
    if (!sessionCode || sessionCode.trim() === "") {
      this.handleConnectionError(
        new Error("Invalid session code: Session code cannot be empty")
      );
      return;
    }

    // Remove any whitespace and convert to uppercase
    sessionCode = sessionCode.trim().toUpperCase();

    // Check if this might be a temporary code
    if (this.isTemporaryCode(sessionCode)) {
      console.warn("⚠️ WARNING: This appears to be a temporary session code!");
      console.warn(
        "⚠️ Ask the host for their PERMANENT session code (usually starts with different characters)"
      );
      // We'll still try to join, but with a warning
    }
    this.role = PlayerRole.CLIENT;
    this.sessionInfo = {
      code: sessionCode,
      isHost: false,
      password,
      role: PlayerRole.CLIENT,
    };

    // Initialize the connection
    try {
      this.initializeConnection();

      // Wait a moment for connection initialization
      await new Promise((resolve) => setTimeout(resolve, 500));

      if (!this.peerConnection) {
        throw new Error("Failed to initialize peer connection");
      }

      // First check if the session exists
      const sessionExists = await remoteSignalingService.checkSessionExists(
        sessionCode
      );

      if (!sessionExists) {
        // Extra advice if this might be a temporary code
        if (this.isTemporaryCode(sessionCode)) {
          this.handleConnectionError(
            new Error(
              `Session not found: ${sessionCode}. This appears to be a TEMPORARY code. Ask the host for the PERMANENT session code.`
            )
          );
        } else {
          this.handleConnectionError(
            new Error(
              `Session not found: ${sessionCode}. Make sure the host has created the session and is still connected.`
            )
          );
        }
        return;
      }

      // Session exists, try to join it
      await remoteSignalingService.joinSession(sessionCode);
      // Set up remote signaling event handlers
      this.setupSignalingHandlers();

      // Set a timeout for the connection attempt
      const connectionTimeout = setTimeout(() => {
        if (this.connectionStatus !== ConnectionStatus.CONNECTED) {
          this.handleConnectionError(
            new Error("Connection attempt timed out. Please try again.")
          );
        }
      }, this.config.timeout);

      // Clear timeout if we connect successfully
      this.onConnected(() => {
        clearTimeout(connectionTimeout);
      });
    } catch (error) {
      console.error("Error during join session process:", error);
      this.handleConnectionError(
        new Error(
          `Failed to join session: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  }

  /**
   * Set up handlers for the remote signaling service
   */
  private setupSignalingHandlers(): void {
    // Remove any existing handlers first to prevent duplicates
    remoteSignalingService.removeAllListeners();

    // Handle SDP offer from remote peer
    remoteSignalingService.on("offer", async (offer) => {
      if (!this.peerConnection) {
        console.error("Cannot process offer: No peer connection");
        return;
      }

      try {
        // Log current connection state
        const currentState = this.peerConnection.signalingState;

        if (currentState !== "stable") {
          if (currentState === "have-local-offer") {
            await this.peerConnection.setLocalDescription({ type: "rollback" });
            // Wait a moment for the rollback to complete
            await new Promise((resolve) => setTimeout(resolve, 100));
          } else if (currentState !== "have-remote-offer") {
            console.warn(`Cannot process offer in state: ${currentState}`);
            return;
          }
        }

        // Set remote description
        await this.peerConnection.setRemoteDescription(offer);
        // If we're the client, create and send answer
        if (this.role === PlayerRole.CLIENT) {
          // Wait a moment to ensure remote description is fully processed
          await new Promise((resolve) => setTimeout(resolve, 100));
          const answer = await this.peerConnection.createAnswer();

          // Verify we're still in the correct state
          if (this.peerConnection.signalingState !== "have-remote-offer") {
            throw new Error(
              `Invalid state for setting answer: ${this.peerConnection.signalingState}`
            );
          }

          await this.peerConnection.setLocalDescription(answer);
          console.log("Sending answer to signaling service");
          remoteSignalingService.sendAnswer(answer);
        }
      } catch (error) {
        console.error("Detailed offer processing error:", error);
        // Don't immediately try to restart the connection, as it might cause a loop
        this.handleConnectionError(
          new Error(
            `Error processing offer: ${
              error instanceof Error ? error.message : String(error)
            }`
          )
        );
      }
    });

    // Handle SDP answer from remote peer
    remoteSignalingService.on("answer", async (answer) => {
      if (!this.peerConnection) {
        console.error("Cannot process answer: No peer connection");
        return;
      }

      try {
        if (this.peerConnection.signalingState === "have-local-offer") {
          await this.peerConnection.setRemoteDescription(answer);
          console.log("Remote answer set successfully");
        } else {
          console.error(
            `Cannot set remote answer in state: ${this.peerConnection.signalingState}`
          );
        }
      } catch (error) {
        console.error("Detailed answer processing error:", error);
        this.handleConnectionError(
          new Error(
            `Error processing answer: ${
              error instanceof Error ? error.message : String(error)
            }`
          )
        );
      }
    });

    // Handle ICE candidates from remote peer
    remoteSignalingService.on("iceCandidate", async (data) => {
      if (!this.peerConnection) return;

      try {
        await this.peerConnection.addIceCandidate(data.candidate);
        if (data.candidate) {
          console.debug("ICE candidate gathered");
          // Send the ICE candidate to the remote peer via signaling service
          remoteSignalingService.sendIceCandidate(data.candidate);
        }
      } catch (error) {
        this.handleConnectionError(
          new Error(
            `Error adding ICE candidate: ${
              error instanceof Error ? error.message : String(error)
            }`
          )
        );
      }
    });

    // Handle connection events
    remoteSignalingService.on("clientJoined", () => {});

    remoteSignalingService.on("hostDisconnected", () => {
      this.handleConnectionClosed();
    });

    remoteSignalingService.on("clientDisconnected", () => {
      // Only relevant for host
      if (this.role === PlayerRole.HOST) {
      }
    });

    remoteSignalingService.on("connectionError", (error) => {
      this.handleConnectionError(error);
    });
  }

  /**
   * Create and send an SDP offer to the remote peer
   * @param iceRestart Whether to restart ICE gathering (optional)
   */
  private async createAndSendOffer(iceRestart?: boolean): Promise<void> {
    if (!this.peerConnection) {
      console.error("Cannot create offer: No peer connection");
      return;
    }

    try {
      // Create the data channel before creating the offer
      this.createDataChannel();

      // Create the offer with ICE restart if needed
      const offerOptions: RTCOfferOptions = {};
      if (iceRestart) {
        offerOptions.iceRestart = true;
      }

      // Create the offer
      const offer = await this.peerConnection.createOffer(offerOptions);
      console.debug(`Offer SDP type: ${offer.type}`);
      await this.peerConnection.setLocalDescription(offer);
      // Send the offer through the signaling service
      remoteSignalingService.sendOffer(offer);
    } catch (error) {
      console.error("Failed to create and send offer:", error);
      this.handleConnectionError(
        new Error(
          `Failed to create offer: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  }

  /**
   * Initialize WebRTC peer connection
   */
  private initializeConnection(): void {
    this.setConnectionStatus(ConnectionStatus.CONNECTING);
    try {
      // Create a new RTCPeerConnection with enhanced configuration
      this.peerConnection = new RTCPeerConnection({
        iceServers: this.config.iceServers,
        iceTransportPolicy: "all",
        iceCandidatePoolSize: 10, // Increase candidate pool for Windows
        bundlePolicy: "max-bundle",
      });
      // Setup connection timeout
      this.connectionTimeout = window.setTimeout(() => {
        if (this.connectionStatus === ConnectionStatus.CONNECTING) {
          console.error(
            "Connection timeout after",
            this.config.timeout / 1000,
            "seconds"
          );
          console.log(
            "ICE gathering state:",
            this.peerConnection?.iceGatheringState
          );

          this.handleConnectionError(
            new Error(
              `Connection timeout after ${
                this.config.timeout / 1000
              }s. Please check your network connection and try again.`
            )
          );
        }
      }, this.config.timeout);

      // Set up event handlers for the peer connection
      this.peerConnection.onicecandidate = (
        event: RTCPeerConnectionIceEvent
      ) => {
        if (event.candidate) {
          console.debug("ICE candidate gathered");
          // Send the ICE candidate to the remote peer via signaling service
          remoteSignalingService.sendIceCandidate(event.candidate);
        }
      };

      this.peerConnection.oniceconnectionstatechange = () => {
        switch (this.peerConnection?.iceConnectionState) {
          case "connected":
          case "completed":
            this.handleConnectionEstablished();
            break;
          case "disconnected":
            // Give it a chance to recover before declaring it failed
            setTimeout(() => {
              if (this.peerConnection?.iceConnectionState === "disconnected") {
                this.handleConnectionClosed();
              }
            }, 5000);
            break;
          case "failed":
            console.error("ICE connection failed - attempting restart");
            this.restartIce();
            break;
          case "closed":
            this.handleConnectionClosed();
            break;
        }
      };

      this.peerConnection.onicegatheringstatechange = () => {};

      this.peerConnection.onsignalingstatechange = () => {};

      this.peerConnection.onconnectionstatechange = () => {
        if (this.peerConnection?.connectionState === "connected") {
          this.handleConnectionEstablished();
        } else if (this.peerConnection?.connectionState === "failed") {
          console.error("Connection state failed - attempting reconnect");
          this.restartConnection();
        }
      };

      this.peerConnection.ondatachannel = (event) => {
        this.setupDataChannel(event.channel);
      };
    } catch (error) {
      console.error("Error creating peer connection:", error);
      this.handleConnectionError(
        new Error(
          `Failed to initialize WebRTC connection: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  }

  /**
   * Attempt to restart ICE connection when it fails
   */
  private restartIce(): void {
    if (!this.peerConnection) return;

    try {
      if (this.role === PlayerRole.HOST) {
        this.createAndSendOffer(true); // Create offer with ICE restart
      }
    } catch (error) {
      console.error("Error restarting ICE:", error);
    }
  }

  /**
   * Try to recreate the entire connection as a last resort
   */
  private async restartConnection(): Promise<void> {
    try {
      // First, cleanup the signaling handlers to prevent race conditions
      remoteSignalingService.removeAllListeners();

      // Close existing connection
      if (this.peerConnection) {
        this.peerConnection.close();
        this.peerConnection = null;
      }

      if (this.dataChannel) {
        this.dataChannel.close();
        this.dataChannel = null;
      }

      // Wait a moment for cleanup
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Store current session info (only if it exists and is valid)
      const currentSession = this.sessionInfo
        ? {
            code: this.sessionInfo.code,
            isHost: this.sessionInfo.isHost,
            password: this.sessionInfo.password,
            role: this.sessionInfo.role,
          }
        : null;

      // Recreate connection
      this.initializeConnection();

      // Wait for connection to initialize
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Restore session info if we had one
      if (currentSession) {
        this.sessionInfo = currentSession;
      }

      // Set up signaling handlers before proceeding
      this.setupSignalingHandlers();

      // If we're the client, we need to rejoin the session
      if (this.role === PlayerRole.CLIENT && this.sessionInfo?.code) {
        await remoteSignalingService.joinSession(this.sessionInfo.code);
      }
      // If host, create a new offer
      else if (this.role === PlayerRole.HOST) {
        await this.createAndSendOffer();
      }
    } catch (error) {
      console.error("Error during connection restart:", error);
      this.handleConnectionError(
        new Error(
          `Failed to restart connection: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  }

  /**
   * Create and set up the WebRTC data channel (for host)
   */
  private createDataChannel(): void {
    if (!this.peerConnection) {
      console.error("Cannot create data channel: No peer connection");
      return;
    }
    try {
      this.dataChannel = this.peerConnection.createDataChannel("gameData", {
        ordered: true,
      });
      console.debug(`Data channel ID: ${this.dataChannel.id}`);
      console.debug(`Data channel ordered: ${this.dataChannel.ordered}`);
      this.setupDataChannel(this.dataChannel);
    } catch (error) {
      console.error("Failed to create data channel:", error);
      this.handleConnectionError(
        new Error(
          `Failed to create data channel: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  }

  /**
   * Set up the data channel event handlers
   */
  private setupDataChannel(channel: RTCDataChannel): void {
    this.dataChannel = channel;

    channel.onopen = () => {
      console.debug(`Channel state: ${channel.readyState}`);
      this.handleConnectionEstablished();
    };

    channel.onclose = () => {
      this.handleConnectionClosed();
    };

    channel.onerror = (error) => {
      console.error(`Data channel '${channel.label}' error:`, error);
      this.handleConnectionError(new Error("Data channel error"));
    };

    channel.onmessage = (event) => {
      try {
        const message: AnyNetworkMessage = JSON.parse(event.data);
        this.handleIncomingMessage(message);
      } catch (error) {
        console.error("Error parsing message:", error);
      }
    };
  }

  /**
   * Handle incoming message from the data channel
   * @param message The message object
   */
  private handleIncomingMessage(message: AnyNetworkMessage): void {
    // Handle ping message (for latency measurement)
    if (message.type === MessageType.PING) {
      // Send pong response
      this.sendMessage({
        type: MessageType.PONG,
        timestamp: Date.now(),
      });

      // If we're the host, also send current game state in response to a ping
      // This helps ensure clients get updated even if they miss state updates
      if (this.role === PlayerRole.HOST) {
        // Use a timeout to ensure the pong message is processed first
        setTimeout(() => {
          // Trigger an event that GameManager can listen for to send the current state
          window.dispatchEvent(new CustomEvent("host-ping-received"));
        }, 50);
      }
      return;
    }

    // Handle pong message (for latency measurement)
    if (message.type === MessageType.PONG) {
      this.lastPongTime = Date.now();

      // If we're the client, we can request a state update after receiving a pong
      if (this.role === PlayerRole.CLIENT) {
        // Trigger an event that GameManager can listen for
        window.dispatchEvent(new CustomEvent("client-pong-received"));
      }
      return;
    }

    // Dispatch to registered handlers
    const handlers = this.messageHandlers.get(message.type);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(message);
        } catch (error) {
          console.error(`Error in message handler for ${message.type}:`, error);
        }
      });
    }
  }

  /**
   * Send a message over the data channel
   */
  public sendMessage(message: AnyNetworkMessage): boolean {
    if (!this.dataChannel || this.dataChannel.readyState !== "open") {
      console.warn("Cannot send message: data channel not open");
      return false;
    }

    try {
      this.dataChannel.send(JSON.stringify(message));
      return true;
    } catch (error) {
      console.error("Error sending message:", error);
      return false;
    }
  }

  /**
   * Send game state to the peer
   */
  public sendGameState(gameStateMessage: GameStateMessage): boolean {
    return this.sendMessage(gameStateMessage);
  }

  /**
   * Register a message handler for a specific message type
   */
  public on<T extends AnyNetworkMessage>(
    type: MessageType,
    handler: (message: T) => void
  ): void {
    if (!this.messageHandlers.has(type)) {
      this.messageHandlers.set(type, []);
    }
    this.messageHandlers.get(type)!.push(handler as any);
  }

  /**
   * Remove a message handler
   */
  public off<T extends AnyNetworkMessage>(
    type: MessageType,
    handler: (message: T) => void
  ): void {
    if (!this.messageHandlers.has(type)) return;

    const handlers = this.messageHandlers.get(type)!;
    const index = handlers.indexOf(handler as any);
    if (index !== -1) {
      handlers.splice(index, 1);
    }
  }

  /**
   * Update the connection status and notify listeners
   */
  private setConnectionStatus(status: ConnectionStatus): void {
    if (status === this.connectionStatus) return;

    const previousStatus = this.connectionStatus;
    this.connectionStatus = status;

    // Notify status change listeners
    this.onStatusChangeListeners.forEach((listener) => {
      try {
        listener(status);
      } catch (error) {
        console.error("Error in status change listener:", error);
      }
    });

    // Notify connected/disconnected listeners
    if (
      status === ConnectionStatus.CONNECTED &&
      previousStatus !== ConnectionStatus.CONNECTED
    ) {
      this.onConnectedListeners.forEach((listener) => {
        try {
          listener();
        } catch (error) {
          console.error("Error in connected listener:", error);
        }
      });
    } else if (
      status === ConnectionStatus.DISCONNECTED &&
      previousStatus === ConnectionStatus.CONNECTED
    ) {
      this.onDisconnectedListeners.forEach((listener) => {
        try {
          listener();
        } catch (error) {
          console.error("Error in disconnected listener:", error);
        }
      });
    }
  }

  /**
   * Handle successful connection establishment
   */
  private handleConnectionEstablished(): void {
    // Clear connection timeout
    if (this.connectionTimeout !== null) {
      clearTimeout(this.connectionTimeout);
      this.connectionTimeout = null;
    }

    this.setConnectionStatus(ConnectionStatus.CONNECTED);

    // Start ping/pong for connection monitoring
    this.startPingPong();
  }

  /**
   * Handle connection closure
   */
  private handleConnectionClosed(): void {
    this.stopPingPong();
    this.setConnectionStatus(ConnectionStatus.DISCONNECTED);
  }

  /**
   * Handle connection error
   */
  private handleConnectionError(error: Error): void {
    console.error("Connection error:", error);

    this.stopPingPong();
    this.setConnectionStatus(ConnectionStatus.ERROR);

    // Notify error listeners
    this.onErrorListeners.forEach((listener) => {
      try {
        listener(error);
      } catch (e) {
        console.error("Error in error listener:", e);
      }
    });
  }

  /**
   * Start ping/pong messages for connection monitoring
   */
  private startPingPong(): void {
    // Send a ping every 5 seconds
    this.pingInterval = window.setInterval(() => {
      if (this.connectionStatus === ConnectionStatus.CONNECTED) {
        this.lastPingTime = Date.now();
        this.sendMessage({
          type: MessageType.PING,
          timestamp: this.lastPingTime,
        });

        // Check if we've received a pong since the last ping
        if (this.lastPingTime - this.lastPongTime > 15000) {
          console.warn(
            "No pong received for 15 seconds, connection may be lost"
          );
        }
      }
    }, 5000);
  }

  /**
   * Stop ping/pong messages
   */
  private stopPingPong(): void {
    if (this.pingInterval !== null) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }

  /**
   * Close the connection
   */
  public close(): void {
    this.stopPingPong();

    if (this.dataChannel) {
      this.dataChannel.close();
      this.dataChannel = null;
    }

    if (this.peerConnection) {
      this.peerConnection.close();
      this.peerConnection = null;
    }

    // Disconnect from signaling service
    remoteSignalingService.disconnect();

    // Reset session info
    this.sessionInfo = null;

    this.setConnectionStatus(ConnectionStatus.DISCONNECTED);
  }

  /**
   * Get the current connection status
   */
  public getConnectionStatus(): ConnectionStatus {
    return this.connectionStatus;
  }

  /**
   * Get the session info
   */
  public getSessionInfo(): SessionInfo | null {
    return this.sessionInfo;
  }

  /**
   * Get the player role (host or client)
   */
  public getRole(): PlayerRole {
    return this.role;
  }

  /**
   * Register a connection status change listener
   */
  public onStatusChange(listener: (status: ConnectionStatus) => void): void {
    this.onStatusChangeListeners.push(listener);
  }

  /**
   * Register a connection established listener
   */
  public onConnected(listener: () => void): void {
    this.onConnectedListeners.push(listener);
  }

  /**
   * Register a connection closed listener
   */
  public onDisconnected(listener: () => void): void {
    this.onDisconnectedListeners.push(listener);
  }

  /**
   * Register an error listener
   */
  public onError(listener: (error: Error) => void): void {
    this.onErrorListeners.push(listener);
  }
}

// Export a singleton instance
export const webRTCService = new WebRTCService();
export default webRTCService;
